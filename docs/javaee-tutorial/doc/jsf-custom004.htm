<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />
        <meta http-equiv="Content-Style-Type" content="text/css" />
        <meta http-equiv="Content-Script-Type" content="text/javascript" />

        <!-- Add DARB meta tags here -->

        <meta name="generator" content="Oracle DARB XHTML Converter (Mode = document) - Version 1.0.24" />
<meta name="date" content="2014-09-06T2:45:1Z" />
<meta name="robots" content="noarchive" />
<meta name="doctitle" content="Creating Custom Component Classes" />
<meta name="relnum" content="Release 7" />
<meta name="partnum" content="E39031-01" />
        <meta name="description" content="A guide to developing enterprise applications for the Java Platform, Enterprise Edition 7 (Java EE 7) using GlassFish Server Open Source Edition." />
        <meta name="keywords" content="Get started with Java EE, get started with Java EE 7, tutorials, Java EE getting started, Java EE getting started guide, Java EE, Java EE 7, Java FX, Web, developer, enterprise, Java EE Tutorial, Java EE 7 Tutorial" />

        <!-- Persistent copyright link from DARB output -->
        <link rel="copyright" href="../../dcommon/html/cpyr.htm" title="Copyright" type="text/html" />

        <!-- Links to Java EE output template style sheets -->
        <link href="../css/javaee-darb-position.css" rel="stylesheet" type="text/css" />
        <link href="../css/javaee-darb-fonts.css" rel="stylesheet" type="text/css" />

        <title>The Java EE 7 Tutorial:Creating Custom Component Classes | Java EE Documentation</title>


    </head>

    <body class="javaee">
        <!-- The following markup is required for accessibility -->
        <noscript>
            JavaScript is not supported by your browser.  JavaScript support is required for full functionality of this page.
        </noscript>


        	<!-- ///////// Container ///////// -->
        	<div id="container">



            <!--///////// Header /////////-->
            <div id="header">
                <div id="headertrail" class="breadcrumb"><a href="http://www.oracle.com/technetwork/java/index.html">Java</a> &gt; <a href="http://www.oracle.com/technetwork/java/javaee/overview/index.html">Java EE </a> &gt; <a href="http://docs.oracle.com/javaee/">Java EE Documentation</a>
                </div>
            </div>   
			<!-- end #header -->
            <!--///////// End Header /////////-->



            <!--///////// Start Side Bar /////////-->
            <div id="sidebar">

                <!-- Sidebar item 1. This <div> is obligatory -->
                <div id="sidebar_version_box" class="type_med_gry">
                    <h1>Release: Java EE 7.0</h1>
                    <p>Last Updated: September, 2014</p>
					 <p><a href="http://docs.oracle.com/javaee/7/tutorial/doc/javaeetutorial7.pdf">Download as PDF</a></p>  
                 </div>
			    <!-- end obligatory sidebar_version_box -->


                <!-- Sidebar item 2 Table of Contents. -->
                <div id="sidebar_toc_box" class="type_med_gry">
                    
                    <div id="toc">

                         <h2 class="tocheader"><a href="preface.htm#GEXAF">Preface</a></h2>
<h2 class="tocheader"><a href="partintro.htm#GFIRP">Part I Introduction</a></h2>
<h2 class="tocheader"><a href="overview.htm#BNAAW"><span class="secnum">1</span> Overview</a></h2>
<h2 class="tocheader"><a href="usingexamples.htm#GFIUD"><span class="secnum">2</span> Using the Tutorial Examples</a></h2>
<h2 class="tocheader"><a href="partplatform.htm#GFIRP2">Part II Platform Basics</a></h2>
<h2 class="tocheader"><a href="resource-creation.htm#GKJIQ2"><span class="secnum">3</span> Resource Creation</a></h2>
<h2 class="tocheader"><a href="injection.htm#GKJIQ3"><span class="secnum">4</span> Injection</a></h2>
<h2 class="tocheader"><a href="packaging.htm#GKJIQ4"><span class="secnum">5</span> Packaging</a></h2>
<h2 class="tocheader"><a href="partwebtier.htm#BNADP">Part III The Web Tier</a></h2>
<h2 class="tocheader"><a href="webapp.htm#BNADR"><span class="secnum">6</span> Getting Started with Web Applications</a></h2>
<h2 class="tocheader"><a href="jsf-intro.htm#BNAPH"><span class="secnum">7</span> JavaServer Faces Technology</a></h2>
<h2 class="tocheader"><a href="jsf-facelets.htm#GIEPX"><span class="secnum">8</span> Introduction to Facelets</a></h2>
<h2 class="tocheader"><a href="jsf-el.htm#GJDDD"><span class="secnum">9</span> Expression Language</a></h2>
<h2 class="tocheader"><a href="jsf-page.htm#BNAQZ"><span class="secnum">10</span> Using JavaServer Faces Technology in Web Pages</a></h2>
<h2 class="tocheader"><a href="jsf-page-core.htm#GJCUT"><span class="secnum">11</span> Using Converters, Listeners, and Validators</a></h2>
<h2 class="tocheader"><a href="jsf-develop.htm#BNATX"><span class="secnum">12</span> Developing with JavaServer Faces Technology</a></h2>
<h2 class="tocheader"><a href="jsf-ajax.htm#GKIOW"><span class="secnum">13</span> Using Ajax with JavaServer Faces Technology</a></h2>
<h2 class="tocheader"><a href="jsf-advanced-cc.htm#GKHXA"><span class="secnum">14</span> Composite Components: Advanced Topics and an Example</a></h2>
<h2 class="tocheader"><a href="jsf-custom.htm#BNAVG"><span class="secnum">15</span> Creating Custom UI Components and Other Custom Objects</a></h2>
<ul style="list-style-type:none">
<li><a href="jsf-custom001.htm#BNAVH"><span class="secnum">15.1</span> Determining Whether You Need a Custom Component or Renderer</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom001.htm#BNAVI"><span class="secnum">15.1.1</span> When to Use a Custom Component</a></li>
<li><a href="jsf-custom001.htm#BNAVJ"><span class="secnum">15.1.2</span> When to Use a Custom Renderer</a></li>
<li><a href="jsf-custom001.htm#BNAVK"><span class="secnum">15.1.3</span> Component, Renderer, and Tag Combinations</a></li>
</ul>
</li>
<li><a href="jsf-custom002.htm#GLPCB"><span class="secnum">15.2</span> Understanding the Image Map Example</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom002.htm#GLPBD"><span class="secnum">15.2.1</span> Why Use JavaServer Faces Technology to Implement an Image Map?</a></li>
<li><a href="jsf-custom002.htm#GLPEM"><span class="secnum">15.2.2</span> Understanding the Rendered HTML</a></li>
<li><a href="jsf-custom002.htm#GLPCD"><span class="secnum">15.2.3</span> Understanding the Facelets Page</a></li>
<li><a href="jsf-custom002.htm#GLPBO"><span class="secnum">15.2.4</span> Configuring Model Data</a></li>
<li><a href="jsf-custom002.htm#GLPEL"><span class="secnum">15.2.5</span> Summary of the Image Map Application Classes</a></li>
</ul>
</li>
<li><a href="jsf-custom003.htm#BNAVT"><span class="secnum">15.3</span> Steps for Creating a Custom Component</a></li>
<li><div id="backgroundColor"><a href="jsf-custom004.htm#BNAVU"><span class="secnum">15.4</span> Creating Custom Component Classes</a><ul style="list-style-type:none">
<li><a href="jsf-custom004.htm#BNAVV"><span class="secnum">15.4.1</span> Specifying the Component Family</a></li>
<li><a href="jsf-custom004.htm#BNAVW"><span class="secnum">15.4.2</span> Performing Encoding</a></li>
<li><a href="jsf-custom004.htm#BNAVX"><span class="secnum">15.4.3</span> Performing Decoding</a></li>
<li><a href="jsf-custom004.htm#BNAVY"><span class="secnum">15.4.4</span> Enabling Component Properties to Accept Expressions</a></li>
<li><a href="jsf-custom004.htm#BNAVZ"><span class="secnum">15.4.5</span> Saving and Restoring State</a></li>
</ul>
</div></li>
<li><a href="jsf-custom005.htm#BNAWA"><span class="secnum">15.5</span> Delegating Rendering to a Renderer</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom005.htm#BNAWB"><span class="secnum">15.5.1</span> Creating the Renderer Class</a></li>
<li><a href="jsf-custom005.htm#BNAWC"><span class="secnum">15.5.2</span> Identifying the Renderer Type</a></li>
</ul>
</li>
<li><a href="jsf-custom006.htm#BNAUT"><span class="secnum">15.6</span> Implementing an Event Listener</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom006.htm#BNAUU"><span class="secnum">15.6.1</span> Implementing Value-Change Listeners</a></li>
<li><a href="jsf-custom006.htm#BNAUV"><span class="secnum">15.6.2</span> Implementing Action Listeners</a></li>
</ul>
</li>
<li><a href="jsf-custom007.htm#BNAWD"><span class="secnum">15.7</span> Handling Events for Custom Components</a></li>
<li><a href="jsf-custom008.htm#BNAWN"><span class="secnum">15.8</span> Defining the Custom Component Tag in a Tag Library Descriptor</a></li>
<li><a href="jsf-custom009.htm#BNATT"><span class="secnum">15.9</span> Using a Custom Component</a></li>
<li><a href="jsf-custom010.htm#BNAUS"><span class="secnum">15.10</span> Creating and Using a Custom Converter</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom010.htm#GLPHB"><span class="secnum">15.10.1</span> Creating a Custom Converter</a></li>
<li><a href="jsf-custom010.htm#BNATU"><span class="secnum">15.10.2</span> Using a Custom Converter</a></li>
</ul>
</li>
<li><a href="jsf-custom011.htm#BNAUW"><span class="secnum">15.11</span> Creating and Using a Custom Validator</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom011.htm#BNAUX"><span class="secnum">15.11.1</span> Implementing the Validator Interface</a></li>
<li><a href="jsf-custom011.htm#BNAUY"><span class="secnum">15.11.2</span> Specifying a Custom Tag</a></li>
<li><a href="jsf-custom011.htm#BNATV"><span class="secnum">15.11.3</span> Using a Custom Validator</a></li>
</ul>
</li>
<li><a href="jsf-custom012.htm#BNATG"><span class="secnum">15.12</span> Binding Component Values and Instances to Managed Bean Properties</a>
<ul style="list-style-type:none">
<li><a href="jsf-custom012.htm#BNATI"><span class="secnum">15.12.1</span> Binding a Component Value to a Property</a></li>
<li><a href="jsf-custom012.htm#BNATJ"><span class="secnum">15.12.2</span> Binding a Component Value to an Implicit Object</a></li>
<li><a href="jsf-custom012.htm#BNATL"><span class="secnum">15.12.3</span> Binding a Component Instance to a Bean Property</a></li>
</ul>
</li>
<li><a href="jsf-custom013.htm#BNATM"><span class="secnum">15.13</span> Binding Converters, Listeners, and Validators to Managed Bean Properties</a></li>
</ul>
<h2 class="tocheader"><a href="jsf-configure.htm#BNAWO"><span class="secnum">16</span> Configuring JavaServer Faces Applications</a></h2>
<h2 class="tocheader"><a href="servlets.htm#BNAFD"><span class="secnum">17</span> Java Servlet Technology</a></h2>
<h2 class="tocheader"><a href="websocket.htm#GKJIQ5"><span class="secnum">18</span> Java API for WebSocket</a></h2>
<h2 class="tocheader"><a href="jsonp.htm#GLRBB"><span class="secnum">19</span> JSON Processing</a></h2>
<h2 class="tocheader"><a href="webi18n.htm#BNAXU"><span class="secnum">20</span> Internationalizing and Localizing Web Applications</a></h2>
<h2 class="tocheader"><a href="partbeanvalidation.htm#sthref1322">Part IV Bean Validation</a></h2>
<h2 class="tocheader"><a href="bean-validation.htm#CHDGJIIA"><span class="secnum">21</span> Introduction to Bean Validation</a></h2>
<h2 class="tocheader"><a href="bean-validation-advanced.htm#GKAHP"><span class="secnum">22</span> Bean Validation: Advanced Topics</a></h2>
<h2 class="tocheader"><a href="partcdi.htm#GJBNR">Part V Contexts and Dependency Injection for Java EE</a></h2>
<h2 class="tocheader"><a href="cdi-basic.htm#GIWHB"><span class="secnum">23</span> Introduction to Contexts and Dependency Injection for Java EE</a></h2>
<h2 class="tocheader"><a href="cdi-basicexamples.htm#GJBLS"><span class="secnum">24</span> Running the Basic Contexts and Dependency Injection Examples</a></h2>
<h2 class="tocheader"><a href="cdi-adv.htm#GJEHI"><span class="secnum">25</span> Contexts and Dependency Injection for Java EE: Advanced Topics</a></h2>
<h2 class="tocheader"><a href="cdi-adv-examples.htm#GKHRE"><span class="secnum">26</span> Running the Advanced Contexts and Dependency Injection Examples</a></h2>
<h2 class="tocheader"><a href="partwebsvcs.htm#BNAYK">Part VI Web Services</a></h2>
<h2 class="tocheader"><a href="webservices-intro.htm#GIJTI"><span class="secnum">27</span> Introduction to Web Services</a></h2>
<h2 class="tocheader"><a href="jaxws.htm#BNAYL"><span class="secnum">28</span> Building Web Services with JAX-WS</a></h2>
<h2 class="tocheader"><a href="jaxrs.htm#GIEPU"><span class="secnum">29</span> Building RESTful Web Services with JAX-RS</a></h2>
<h2 class="tocheader"><a href="jaxrs-client.htm#BABEIGIH"><span class="secnum">30</span> Accessing REST Resources with the JAX-RS Client API</a></h2>
<h2 class="tocheader"><a href="jaxrs-advanced.htm#GJJXE"><span class="secnum">31</span> JAX-RS: Advanced Topics and an Example</a></h2>
<h2 class="tocheader"><a href="partentbeans.htm#BNBLR">Part VII Enterprise Beans</a></h2>
<h2 class="tocheader"><a href="ejb-intro.htm#GIJSZ"><span class="secnum">32</span> Enterprise Beans</a></h2>
<h2 class="tocheader"><a href="ejb-gettingstarted.htm#GIJRE"><span class="secnum">33</span> Getting Started with Enterprise Beans</a></h2>
<h2 class="tocheader"><a href="ejb-basicexamples.htm#GIJRB"><span class="secnum">34</span> Running the Enterprise Bean Examples</a></h2>
<h2 class="tocheader"><a href="ejb-embedded.htm#GKCQZ"><span class="secnum">35</span> Using the Embedded Enterprise Bean Container</a></h2>
<h2 class="tocheader"><a href="ejb-async.htm#GKIDZ"><span class="secnum">36</span> Using Asynchronous Method Invocation in Session Beans</a></h2>
<h2 class="tocheader"><a href="partpersist.htm#BNBPY">Part VIII Persistence</a></h2>
<h2 class="tocheader"><a href="persistence-intro.htm#BNBPZ"><span class="secnum">37</span> Introduction to the Java Persistence API</a></h2>
<h2 class="tocheader"><a href="persistence-basicexamples.htm#GIJST"><span class="secnum">38</span> Running the Persistence Examples</a></h2>
<h2 class="tocheader"><a href="persistence-querylanguage.htm#BNBTG"><span class="secnum">39</span> The Java Persistence Query Language</a></h2>
<h2 class="tocheader"><a href="persistence-criteria.htm#GJITV"><span class="secnum">40</span> Using the Criteria API to Create Queries</a></h2>
<h2 class="tocheader"><a href="persistence-string-queries.htm#GKJIQ"><span class="secnum">41</span> Creating and Using String-Based Criteria Queries</a></h2>
<h2 class="tocheader"><a href="persistence-locking.htm#GKJJF"><span class="secnum">42</span> Controlling Concurrent Access to Entity Data with Locking</a></h2>
<h2 class="tocheader"><a href="persistence-entitygraphs.htm#BABIJIAC"><span class="secnum">43</span> Creating Fetch Plans with Entity Graphs</a></h2>
<h2 class="tocheader"><a href="persistence-cache.htm#GKJIA"><span class="secnum">44</span> Using a Second-Level Cache with Java Persistence API Applications</a></h2>
<h2 class="tocheader"><a href="partmessaging.htm#GFIRP3">Part IX Messaging</a></h2>
<h2 class="tocheader"><a href="jms-concepts.htm#BNCDQ"><span class="secnum">45</span> Java Message Service Concepts</a></h2>
<h2 class="tocheader"><a href="jms-examples.htm#BNCGV"><span class="secnum">46</span> Java Message Service Examples</a></h2>
<h2 class="tocheader"><a href="partsecurity.htm#GIJRP">Part X Security</a></h2>
<h2 class="tocheader"><a href="security-intro.htm#BNBWJ"><span class="secnum">47</span> Introduction to Security in the Java EE Platform</a></h2>
<h2 class="tocheader"><a href="security-webtier.htm#BNCAS"><span class="secnum">48</span> Getting Started Securing Web Applications</a></h2>
<h2 class="tocheader"><a href="security-javaee.htm#BNBYK"><span class="secnum">49</span> Getting Started Securing Enterprise Applications</a></h2>
<h2 class="tocheader"><a href="security-advanced.htm#GJJWX"><span class="secnum">50</span> Java EE Security: Advanced Topics</a></h2>
<h2 class="tocheader"><a href="partsupporttechs.htm#GIJUE">Part XI Java EE Supporting Technologies</a></h2>
<h2 class="tocheader"><a href="transactions.htm#BNCIH"><span class="secnum">51</span> Transactions</a></h2>
<h2 class="tocheader"><a href="resources.htm#BNCJH"><span class="secnum">52</span> Resource Adapters and Contracts</a></h2>
<h2 class="tocheader"><a href="connectorexample.htm#GLODB"><span class="secnum">53</span> The Resource Adapter Examples</a></h2>
<h2 class="tocheader"><a href="interceptors.htm#GKEED"><span class="secnum">54</span> Using Java EE Interceptors</a></h2>
<h2 class="tocheader"><a href="batch-processing.htm#GKJIQ6"><span class="secnum">55</span> Batch Processing</a></h2>
<h2 class="tocheader"><a href="concurrency-utilities.htm#GKJIQ8"><span class="secnum">56</span> Concurrency Utilities for Java EE</a></h2>
<h2 class="tocheader"><a href="partcasestudies.htm#GKGJW">Part XII Case Studies</a></h2>
<h2 class="tocheader"><a href="dukes-bookstore.htm#GLNVI"><span class="secnum">57</span> Duke's Bookstore Case Study Example</a></h2>
<h2 class="tocheader"><a href="dukes-tutoring.htm#GKAEE"><span class="secnum">58</span> Duke's Tutoring Case Study Example</a></h2>
<h2 class="tocheader"><a href="dukes-forest.htm#GLNPW"><span class="secnum">59</span> Duke's Forest Case Study Example</a></h2>
<h2 class="tocheader"><a href="index.htm">Index</a></h2>
 

                    </div><!-- End toc box -->
                </div>
				<!-- End sidebar_toc box -->


                <!-- Sidebar item feedback -->
                <div id="sidebar_feedback_box" class="type_med_gry">
                    <p class="boxtitle">Feedback</p>
                    <p><a href="http://docs.oracle.com/javaee/support/feedback.htm">Send us feedback about this document.</a></p>
                </div>
				<!-- end sidebar_feedback_box -->

            </div>
			<!-- end #sidebar -->
            <!--///////// End Side Bar /////////-->




            <!--///////// Main Content /////////-->
            <div id="mainContent">

                <!-- Book Info div is used only for multipage documents -->
                <div id="bookTitle">
                    <h1>The Java EE 7 Tutorial  </h1>
                </div>
			   <!-- End BookInfo div tag -->



                <!-- START NEXT_PREVIOUS BUTTONS -->
				<div class="pagestepper">
<table class="simple oac_no_warn" summary="" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td><div align="left"><a href="jsf-custom003.htm"><img src="../images/previouspage.gif" alt="Previous" border="0" /></a></div></td>
<td><div align="right"><a href="jsf-custom005.htm"><img src="../images/nextpage.gif" alt="Next" border="0" /></a></div></td>
</tr>
</tbody></table>
</div>              
                <!-- END NEXT_PREVIOUS BUTTONS -->




                <!-- /////////////// Start content copied from DARB output ////////////// -->
				<div class="ind">

 				<!-- [REPLACE_INI_TITLE_PAGE_CONTENTS] -->
				 <a id="BNAVU" name="BNAVU"></a><a id="JEETT00381" name="JEETT00381"></a>
<div class="sect1">
<h1 class="sect1"><span class="secnum">15.4</span> <a id="sthref896" name="sthref896"></a>Creating Custom Component Classes</h1>
<p>As explained in <a href="jsf-custom001.htm#BNAVI">When to Use a Custom Component</a>, a component class defines the state and behavior of a UI component. The state information includes the component's type, identifier, and local value. The behavior defined by the component class includes the following:</p>
<ul>
<li>
<p><a id="sthref897" name="sthref897"></a>Decoding (converting the request parameter to the component's local value)</p>
</li>
<li>
<p><a id="sthref898" name="sthref898"></a>Encoding (converting the local value into the corresponding markup)</p>
</li>
<li>
<p>Saving the state of the component</p>
</li>
<li>
<p>Updating the bean value with the local value</p>
</li>
<li>
<p>Processing validation on the local value</p>
</li>
<li>
<p>Queueing events</p>
</li>
</ul>
<p><a id="sthref899" name="sthref899"></a>The <code>javax.faces.component.UIComponentBase</code> class defines the default behavior of a component class. All the classes representing the standard components extend from <code>UIComponentBase</code>. These classes add their own behavior definitions, as your custom component class will do.</p>
<p><a id="sthref900" name="sthref900"></a>Your custom component class must either extend <code>UIComponentBase</code> directly or extend a class representing one of the standard components. These classes are located in the <code>javax.faces.component</code> package, and their names begin with <code>UI</code>.</p>
<p>If your custom component serves the same purpose as a standard component, you should extend that standard component rather than directly extend <code>UIComponentBase</code>. For example, suppose you want to create an editable menu component. It makes sense to have this component extend <code>UISelectOne</code> rather than <code>UIComponentBase</code> because you can reuse the behavior already defined in <code>UISelectOne</code>. The only new functionality you need to define is to make the menu editable.</p>
<p>Whether you decide to have your component extend <code>UIComponentBase</code> or a standard component, you might also want your component to implement one or more of these behavioral interfaces defined in the <code>javax.faces.component</code> package:</p>
<ul>
<li>
<p><a id="sthref901" name="sthref901"></a><code>ActionSource</code>: Indicates that the component can fire a <code>javax.faces.event.ActionEvent</code></p>
</li>
<li>
<p><a id="sthref902" name="sthref902"></a><code>ActionSource2</code>: Extends <code>ActionSource</code> and allows component properties referencing methods that handle action events to use method expressions as defined by the EL</p>
</li>
<li>
<p><a id="sthref903" name="sthref903"></a><code>EditableValueHolder</code>: Extends <code>ValueHolder</code> and specifies additional features for editable components, such as validation and emitting value-change events</p>
</li>
<li>
<p><a id="sthref904" name="sthref904"></a><code>NamingContainer</code>: Mandates that each component rooted at this component has a unique ID</p>
</li>
<li>
<p><a id="sthref905" name="sthref905"></a><code>StateHolder</code>: Denotes that a component has state that must be saved between requests</p>
</li>
<li>
<p><a id="sthref906" name="sthref906"></a><code>ValueHolder</code>: Indicates that the component maintains a local value as well as the option of accessing data in the model tier</p>
</li>
</ul>
<p>If your component extends <code>UIComponentBase</code>, it automatically implements only <code>StateHolder</code>. Because all components directly or indirectly extend <code>UIComponentBase</code>, they all implement <code>StateHolder</code>. Any component that implements <code>StateHolder</code> also implements the <code>StateHelper</code> interface, which extends <code>StateHolder</code> and defines a <code>Map</code>-like contract that makes it easy for components to save and restore a partial view state.</p>
<p>If your component extends one of the other standard components, it might also implement other behavioral interfaces in addition to <code>StateHolder</code>. If your component extends <code>UICommand</code>, it automatically implements <code>ActionSource2</code>. If your component extends <code>UIOutput</code> or one of the component classes that extend <code>UIOutput</code>, it automatically implements <code>ValueHolder</code>. If your component extends <code>UIInput</code>, it automatically implements <code>EditableValueHolder</code> and <code>ValueHolder</code>. See the JavaServer Faces API documentation to find out what the other component classes implement.</p>
<p>You can also make your component explicitly implement a behavioral interface that it doesn't already by virtue of extending a particular standard component. For example, if you have a component that extends <code>UIInput</code> and you want it to fire action events, you must make it explicitly implement <code>ActionSource2</code> because a <code>UIInput</code> component doesn't automatically implement this interface.</p>
<p>The Duke's Bookstore image map example has two component classes: <code>AreaComponent</code> and <code>MapComponent</code>. The <code>MapComponent</code> class extends <code>UICommand</code> and therefore implements <code>ActionSource2</code>, which means it can fire action events when a user clicks on the map. The <code>AreaComponent</code> class extends the standard component <code>UIOutput</code>. The <code>@FacesComponent</code> annotation registers the components with the JavaServer Faces implementation:</p>
<pre xml:space="preserve" class="oac_no_warn">
@FacesComponent("DemoMap")
public class MapComponent extends UICommand {...}

@FacesComponent("DemoArea")
public class AreaComponent extends UIOutput {...}
</pre>
<p>The <code>MapComponent</code> class represents the component corresponding to the <code>bookstore:map</code> tag:</p>
<pre xml:space="preserve" class="oac_no_warn">
&lt;bookstore:map id="bookMap" 
               current="map1" 
               immediate="true"
               action="bookstore"&gt;
    ...
&lt;/bookstore:map&gt;
</pre>
<p>The <code>AreaComponent</code> class represents the component corresponding to the <code>bookstore:area</code> tag:</p>
<pre xml:space="preserve" class="oac_no_warn">
&lt;bookstore:area id="map1" value="#{Book201}" 
                onmouseover="resources/images/book_201.jpg" 
                onmouseout="resources/images/book_all.jpg" 
                targetImage="mapImage"/&gt;
</pre>
<p><code>MapComponent</code> has one or more <code>AreaComponent</code> instances as children. Its behavior consists of the following actions:</p>
<ul>
<li>
<p>Retrieving the value of the currently selected area</p>
</li>
<li>
<p>Defining the properties corresponding to the component's values</p>
</li>
<li>
<p>Generating an event when the user clicks on the image map</p>
</li>
<li>
<p>Queuing the event</p>
</li>
<li>
<p>Saving its state</p>
</li>
<li>
<p>Rendering the HTML <code>map</code> tag and the HTML <code>input</code> tag</p>
</li>
</ul>
<p><code>MapComponent</code> delegates the rendering of the HTML <code>map</code> and <code>input</code> tags to the <code>MapRenderer</code> class.</p>
<p><code>AreaComponent</code> is bound to a bean that stores the shape and coordinates of the region of the image map. You will see how all this data is accessed through the value expression in <a href="jsf-custom005.htm#BNAWB">Creating the Renderer Class</a>. The behavior of <code>AreaComponent</code> consists of the following:</p>
<ul>
<li>
<p>Retrieving the shape and coordinate data from the bean</p>
</li>
<li>
<p>Setting the value of the hidden tag to the <code>id</code> of this component</p>
</li>
<li>
<p>Rendering the <code>area</code> tag, including the JavaScript for the <code>onmouseover</code>, <code>onmouseout</code>, and <code>onclick</code> functions</p>
</li>
</ul>
<p>Although these tasks are actually performed by <code>AreaRenderer</code>, <code>AreaComponent</code> must delegate the tasks to <code>AreaRenderer</code>. See <a href="jsf-custom005.htm#BNAWA">Delegating Rendering to a Renderer</a> for more information.</p>
<p>The rest of this section describes the tasks that <code>MapComponent</code> performs as well as the encoding and decoding that it delegates to <code>MapRenderer</code>. <a href="jsf-custom007.htm#BNAWD">Handling Events for Custom Components</a> details how <code>MapComponent</code> handles events.</p>
<a id="BNAVV" name="BNAVV"></a><a id="JEETT00986" name="JEETT00986"></a>
<div class="sect2">
<h2 class="sect2"><span class="secnum">15.4.1</span> Specifying the Component Family</h2>
<p>If your custom component class delegates rendering, it needs to override the <code>getFamily</code> method of <code>UIComponent</code> to return the identifier of a <span class="glossaryterm">component family</span>, which is used to refer to a component or set of components that can be rendered by a renderer or set of renderers. The component family is used along with the renderer type to look up renderers that can render the component:</p>
<pre xml:space="preserve" class="oac_no_warn">
public String getFamily() {
    return ("Map");
}
</pre>
<p>The component family identifier, <code>Map</code>, must match that defined by the <code>component-family</code> elements included in the component and renderer configurations in the application configuration resource file. <a href="jsf-configure010.htm#BNAXH">Registering a Custom Renderer with a Render Kit</a> explains how to define the component family in the renderer configuration. <a href="jsf-configure011.htm#BNAXI">Registering a Custom Component</a> explains how to define the component family in the component configuration.</p>
</div>
<!-- class="sect2" -->
<a id="BNAVW" name="BNAVW"></a><a id="JEETT00987" name="JEETT00987"></a>
<div class="sect2">
<h2 class="sect2"><span class="secnum">15.4.2</span> <a id="sthref907" name="sthref907"></a>Performing Encoding</h2>
<p><a id="sthref908" name="sthref908"></a>During the Render Response phase, the JavaServer Faces implementation processes the encoding methods of all components and their associated renderers in the view. The encoding methods convert the current local value of the component into the corresponding markup that represents it in the response.</p>
<p><a id="sthref909" name="sthref909"></a><a id="sthref910" name="sthref910"></a><a id="sthref911" name="sthref911"></a><a id="sthref912" name="sthref912"></a>The <code>UIComponentBase</code> class defines a set of methods for rendering markup: <code>encodeBegin</code>, <code>encodeChildren</code>, and <code>encodeEnd</code>. If the component has child components, you might need to use more than one of these methods to render the component; otherwise, all rendering should be done in <code>encodeEnd</code>. Alternatively, you can use the <code>encodeALL</code> method, which encompasses all the methods.</p>
<p>Because <code>MapComponent</code> is a parent component of <code>AreaComponent</code>, the <code>area</code> tags must be rendered after the beginning <code>map</code> tag and before the ending <code>map</code> tag. To accomplish this, the <code>MapRenderer</code> class renders the beginning <code>map</code> tag in <code>encodeBegin</code> and the rest of the <code>map</code> tag in <code>encodeEnd</code>.</p>
<p>The JavaServer Faces implementation automatically invokes the <code>encodeEnd</code> method of <code>AreaComponent</code>'s renderer after it invokes <code>MapRenderer</code>'s <code>encodeBegin</code> method and before it invokes <code>MapRenderer</code>'s <code>encodeEnd</code> method. If a component needs to perform the rendering for its children, it does this in the <code>encodeChildren</code> method.</p>
<p>Here are the <code>encodeBegin</code> and <code>encodeEnd</code> methods of <code>MapRenderer</code>:</p>
<pre xml:space="preserve" class="oac_no_warn">
@Override
public void encodeBegin(FacesContext context, UIComponent component) 
        throws IOException {
    if ((context == null)|| (component == null)) {
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    ResponseWriter writer = context.getResponseWriter();
    writer.startElement("map", map);
    writer.writeAttribute("name", map.getId(), "id");
}

@Override
public void encodeEnd(FacesContext context, UIComponent component) 
        throws IOException {
    if ((context == null) || (component == null)){
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    ResponseWriter writer = context.getResponseWriter();
    writer.startElement("input", map);
    writer.writeAttribute("type", "hidden", null);
    writer.writeAttribute("name", getName(context,map), "clientId");
    writer.endElement("input");
    writer.endElement("map");
}
</pre>
<p>Notice that <code>encodeBegin</code> renders only the beginning <code>map</code> tag. The <code>encodeEnd</code> method renders the <code>input</code> tag and the ending <code>map</code> tag.</p>
<p><a id="sthref913" name="sthref913"></a>The encoding methods accept a <code>UIComponent</code> argument and a <code>javax.faces.context.FacesContext</code> argument. The <code>FacesContext</code> instance contains all the information associated with the current request. The <code>UIComponent</code> argument is the component that needs to be rendered.</p>
<p>The rest of the method renders the markup to the <code>javax.faces.context.ResponseWriter</code> instance, which writes out the markup to the current response. This basically involves passing the HTML tag names and attribute names to the <code>ResponseWriter</code> instance as strings, retrieving the values of the component attributes, and passing these values to the <code>ResponseWriter</code> instance.</p>
<p>The <code>startElement</code> method takes a <code>String</code> (the name of the tag) and the component to which the tag corresponds (in this case, <code>map</code>). (Passing this information to the <code>ResponseWriter</code> instance helps design-time tools know which portions of the generated markup are related to which components.)</p>
<p>After calling <code>startElement</code>, you can call <code>writeAttribute</code> to render the tag's attributes. The <code>writeAttribute</code> method takes the name of the attribute, its value, and the name of a property or attribute of the containing component corresponding to the attribute. The last parameter can be null, and it won't be rendered.</p>
<p>The <code>name</code> attribute value of the <code>map</code> tag is retrieved using the <code>getId</code> method of <code>UIComponent</code>, which returns the component's unique identifier. The <code>name</code> attribute value of the <code>input</code> tag is retrieved using the <code>getName(FacesContext, UIComponent)</code> method of <code>MapRenderer</code>.</p>
<p>If you want your component to perform its own rendering but delegate to a renderer if there is one, include the following lines in the encoding method to check whether there is a renderer associated with this component:</p>
<pre xml:space="preserve" class="oac_no_warn">
if (getRendererType() != null) {
    super.encodeEnd(context);
    return;
}
</pre>
<p>If there is a renderer available, this method invokes the superclass's <code>encodeEnd</code> method, which does the work of finding the renderer. The <code>MapComponent</code> class delegates all rendering to <code>MapRenderer</code>, so it does not need to check for available renderers.</p>
<p>In some custom component classes that extend standard components, you might need to implement other methods in addition to <code>encodeEnd</code>. For example, if you need to retrieve the component's value from the request parameters, you must also implement the <code>decode</code> method.</p>
</div>
<!-- class="sect2" -->
<a id="BNAVX" name="BNAVX"></a><a id="JEETT00988" name="JEETT00988"></a>
<div class="sect2">
<h2 class="sect2"><span class="secnum">15.4.3</span> <a id="sthref914" name="sthref914"></a>Performing Decoding</h2>
<p><a id="sthref915" name="sthref915"></a><a id="sthref916" name="sthref916"></a>During the Apply Request Values phase, the JavaServer Faces implementation processes the <code>decode</code> methods of all components in the tree. The <code>decode</code> method extracts a component's local value from incoming request parameters and uses a <code>javax.faces.convert.Converter</code> implementation to convert the value to a type that is acceptable to the component class.</p>
<p><a id="sthref917" name="sthref917"></a><a id="sthref918" name="sthref918"></a>A custom component class or its renderer must implement the <code>decode</code> method only if it must retrieve the local value or if it needs to queue events. The component queues the event by calling <code>queueEvent</code>.</p>
<p>Here is the <code>decode</code> method of <code>MapRenderer</code>:</p>
<pre xml:space="preserve" class="oac_no_warn">
@Override
public void decode(FacesContext context, UIComponent component) {
    if ((context == null) || (component == null)) {
        throw new NullPointerException();
    }
    MapComponent map = (MapComponent) component;
    String key = getName(context, map);
    String value = (String) context.getExternalContext().
            getRequestParameterMap().get(key);
    if (value != null)
        map.setCurrent(value);
    }
}
</pre>
<p>The <code>decode</code> method first gets the name of the hidden <code>input</code> field by calling <code>getName(FacesContext, UIComponent)</code>. It then uses that name as the key to the request parameter map to retrieve the current value of the <code>input</code> field. This value represents the currently selected area. Finally, it sets the value of the <code>MapComponent</code> class's <code>current</code> attribute to the value of the <code>input</code> field.</p>
</div>
<!-- class="sect2" -->
<a id="BNAVY" name="BNAVY"></a><a id="JEETT00989" name="JEETT00989"></a>
<div class="sect2">
<h2 class="sect2"><span class="secnum">15.4.4</span> Enabling Component Properties to Accept Expressions</h2>
<p><a id="sthref919" name="sthref919"></a><a id="sthref920" name="sthref920"></a>Nearly all the attributes of the standard JavaServer Faces tags can accept expressions, whether they are value expressions or method expressions. It is recommended that you also enable your component attributes to accept expressions because it gives you much more flexibility when you write Facelets pages.</p>
<p>To enable the attributes to accept expressions, the component class must implement getter and setter methods for the component properties. These methods can use the facilities offered by the <code>StateHelper</code> interface to store and retrieve not only the values for these properties but also the state of the components across multiple requests.</p>
<p>Because <code>MapComponent</code> extends <code>UICommand</code>, the <code>UICommand</code> class already does the work of getting the <code>ValueExpression</code> and <code>MethodExpression</code> instances associated with each of the attributes that it supports. Similarly, the <code>UIOutput</code> class that <code>AreaComponent</code> extends already obtains the <code>ValueExpression</code> instances for its supported attributes. For both components, the simple getter and setter methods store and retrieve the key values and state for the attributes, as shown in this code fragment from <code>AreaComponent</code>:</p>
<pre xml:space="preserve" class="oac_no_warn">
enum PropertyKeys {
    alt, coords, shape, targetImage;
}
public String getAlt() {
    return (String) getStateHelper().eval(PropertyKeys.alt, null);
}
public void setAlt(String alt) {
    getStateHelper().put(PropertyKeys.alt, alt);
}
...
</pre>
<p>However, if you have a custom component class that extends <code>UIComponentBase</code>, you will need to implement the methods that get the <code>ValueExpression</code> and <code>MethodExpression</code> instances associated with those attributes that are enabled to accept expressions. For example, you could include a method that gets the <code>ValueExpression</code> instance for the <code>immediate</code> attribute:</p>
<pre xml:space="preserve" class="oac_no_warn">
public boolean isImmediate() {
    if (this.immediateSet) {
        return (this.immediate);
    }
    ValueExpression ve = getValueExpression("immediate");
    if (ve != null) {
        Boolean value = (Boolean) ve.getValue(
            getFacesContext().getELContext());
        return (value.booleanValue());
    } else {
        return (this.immediate);
    }
}
</pre>
<p>The properties corresponding to the component attributes that accept method expressions must accept and return a <code>MethodExpression</code> object. For example, if <code>MapComponent</code> extended <code>UIComponentBase</code> instead of <code>UICommand</code>, it would need to provide an <code>action</code> property that returns and accepts a <code>MethodExpression</code> object:</p>
<pre xml:space="preserve" class="oac_no_warn">
public MethodExpression getAction() {
    return (this.action);
}
public void setAction(MethodExpression action) {
    this.action = action;
}
</pre></div>
<!-- class="sect2" -->
<a id="BNAVZ" name="BNAVZ"></a><a id="JEETT00990" name="JEETT00990"></a>
<div class="sect2">
<h2 class="sect2"><span class="secnum">15.4.5</span> <a id="sthref921" name="sthref921"></a>Saving and Restoring State</h2>
<p>As described in <a href="#BNAVY">Enabling Component Properties to Accept Expressions</a>, use of the <code>StateHelper</code> interface facilities allows you to save the component's state at the same time you set and retrieve property values. The <code>StateHelper</code> implementation allows partial state saving; it saves only the changes in the state since the initial request, not the entire state, because the full state can be restored during the Restore View phase.</p>
<p><a id="sthref922" name="sthref922"></a><a id="sthref923" name="sthref923"></a><a id="sthref924" name="sthref924"></a>Component classes that implement <code>StateHolder</code> may prefer to implement the <code>saveState(FacesContext)</code> and <code>restoreState(FacesContext, Object)</code> methods to help the JavaServer Faces implementation save and restore the state of components across multiple requests.</p>
<p>To save a set of values, you can implement the <code>saveState(FacesContext)</code> method. This method is called during the Render Response phase, during which the state of the response is saved for processing on subsequent requests. Here is a hypothetical method from <code>MapComponent</code>, which has only one attribute, <code>current</code>:</p>
<pre xml:space="preserve" class="oac_no_warn">
@Override
public Object saveState(FacesContext context) {
    Object values[] = new Object[2];
    values[0] = super.saveState(context);
    values[1] = current;
    return (values);
}
</pre>
<p>This method initializes an array, which will hold the saved state. It next saves all of the state associated with the component.</p>
<p><a id="sthref925" name="sthref925"></a>A component that implements <code>StateHolder</code> may also provide an implementation for <code>restoreState(FacesContext, Object)</code>, which restores the state of the component to that saved with the <code>saveState(FacesContext)</code> method. The <code>restoreState(FacesContext, Object)</code> method is called during the Restore View phase, during which the JavaServer Faces implementation checks whether there is any state that was saved during the last Render Response phase and needs to be restored in preparation for the next postback.</p>
<p>Here is a hypothetical <code>restoreState(FacesContext, Object)</code> method from <code>MapComponent</code>:</p>
<pre xml:space="preserve" class="oac_no_warn">
public void restoreState(FacesContext context, Object state) {
    Object values[] = (Object[]) state;
    super.restoreState(context, values[0]);
    current = (String) values[1];
}
</pre>
<p>This method takes a <code>FacesContext</code> and an <code>Object</code> instance, representing the array that is holding the state for the component. This method sets the component's properties to the values saved in the <code>Object</code> array.</p>
<p><a id="sthref926" name="sthref926"></a>Whether or not you implement these methods in your component class, you can use the <code>javax.faces.STATE_SAVING_METHOD</code> context parameter to specify in the deployment descriptor where you want the state to be saved: either <code>client</code> or <code>server</code>. If state is saved on the client, the state of the entire view is rendered to a hidden field on the page. By default, the state is saved on the server.</p>
<p>The web applications in the Duke's Forest case study save their view state on the client.</p>
<p>Saving state on the client uses more bandwidth as well as more client resources, whereas saving it on the server uses more server resources. You may also want to save state on the client if you expect your users to disable cookies.</p>
</div>
<!-- class="sect2" --></div>
<!-- class="sect1" --> 
				
                </div>  
				<!-- End ind div tag -->
                <!-- /////////////// End content copied from DARB output ////////////// -->



                

                <!-- START NEXT_PREVIOUS BUTTONS -->
				<div class="pagestepper">
<table class="simple oac_no_warn" summary="" cellpadding="0" cellspacing="0" width="100%">
<tbody>
<tr>
<td><div align="left"><a href="jsf-custom003.htm"><img src="../images/previouspage.gif" alt="Previous" border="0" /></a></div></td>
<td><div align="right"><a href="jsf-custom005.htm"><img src="../images/nextpage.gif" alt="Next" border="0" /></a></div></td>
</tr>
</tbody></table>
</div>		          
                <!-- END NEXT_PREVIOUS BUTTONS -->


                <!-- end #mainContent -->
            </div>
			<br class="clearfloat" />
            <!--///////// End Main Content /////////-->



            <!--///////// Footer /////////-->
            <div id="footer">

                <!-- Start SiteCatalyst (Omniture) code   -->
                <script type="text/javascript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code_download.js"></script>
                <script type="text/javascript" src="http://www.oracle.com/ocom/groups/systemobject/@mktg_admin/documents/systemobject/s_code.js"></script>


                <!-- ********** DO NOT ALTER ANYTHING BELOW THIS LINE ! *********** -->

                <!--  Below code will send the info to Omniture server -->
                <script  type="text/javascript">var s_code=s.t();if(s_code)document.write(s_code)</script>

                <!-- End SiteCatalyst code -->



                <!-- Footer Legal info -->
                <div id="blur"><span class="copyrightlogo">Copyright 2014, Oracle and/or its affiliates. All rights reserved.</span>
                    <a href="../../dcommon/html/cpyr.htm"><br />
                        <span class="copyrightlogo">Legal Notices</span></a></div> <!-- End footer legal info -->

                <!-- end #footer -->
            </div>
            <!--///////// End Footer /////////-->

            <!-- end #container -->
        </div>


    </body>
</html>

